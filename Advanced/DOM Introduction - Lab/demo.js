// DOM - Document Object Model

// Browser API - BOM (Browser Object Model) - 

// window - глобалния обект. Тук се намират всичките API-та
// Променливите с var се закачат в window. С let не.

// DOM - логическо дърво, което се създава, когато браузърът се опитва да достъпи страница.
// HTML е това, което се вижда на браузъра. Браузъра го чете, интерпретира го, създава ДОМ дървото и създава страницата на екрана. Тези елементи са обекти.

// Методи: Действия, които можем да изпълняваме в/у HTML елементите
// Свойства: Данни, които ние можем да променяме или да четем

// Между ДОМ дървото, което е в памметта на компютъра и уеб страницата, която виждаме на екрана има двупосочна връзка, която браузъра осъществява.


// innerHTML - взима всичко от елемента. Ако напишем таг за бутон вътре, ще го създаде
//  text.content -ЗА СТАТИЧНИ ЕЛЕМЕНТИ(които имат само текст) взима само текста от елемента. Ако напишем таг за бутон вътре, ще го изкара като текст
//  value - ЗА ДИНАМИЧНИ ЕЛЕМЕНТИ(в които потребителя може да пише). Това е стойността на елемента. Изкарва стойност.

//  event handler - слушател за събитие. Функция, която обработва събитие.Напр.:
//  <button onclick = "console.log(Button is clicked)>Click Me</button>">. Този код ще се изпълни, когато потребителят кликне на бутона.

//  script таговете е прието да се пишат най-отдолу. В тях можем да си декларираме функции.
//  За предпочитане е да се използва отделен файл. Пише се <script src="app.js"></script>. По този начин браузърът ще търси файла на същото място, където е HTML-a.

//  Свойства на HTML елементите:
//  src, onclick...това са атрибути в HTML. Те дават първоначална стойност за някои свойства.
//  Можем да променяме атрибутите...setAtribute...
//  Същото нещо в ДОМ дървото са свойства (както параметри и аргументи на функции)


//  style - променя стила в CSS
//  text.content
//  value - получаваме Стринг, трябва да го парснем към число.


// function editElement(element, match, replacer) { функцията приема елемент, съвпадение и промяна
    
//     const content = element.textContent; декларираме променлива, която е = на съдържанието на дадения елемент
//     const matcher = new RegExp(match, 'g'); създаваме РегЕкс 
//     const edited = content.replace(matcher, replacer); декларираме променлива за промяната на съвпадението с дадения replacer
//     element.textContent = edited;  елементът ни приема новата подадена стойност
//     }


// Селектиране на DOM елементи

// document.getElementById("") - връща ни референция към елемента, след това можем да му вземем textContent-a. Трябва да има само един елемент с такова id.

// document.getElementsByClassName("") - връща колекцията на елементите на класа с даденото име

// document.getElementsByТагName("li") - също връша колекция като ClassName

// querySelector("button") - взима първия елемент от колекцията
// querySelectorAll() - взима всички елементи от колекцията

// querySelector('.rows') - . хваща по клас. Ако няма елементи връща null
// querySelector('#title') - # хващa по id. 

//  #content div - хваща id content И ВЪТРЕ В НЕГО div

//  .node, .alert - хваща клас node или alert

// Node list - може да съдържа всякакъв тип обекти, включително text node и whitespace. Връща се само от querySelector. Не могат да имат деца. Имат length.
// HTML колекцията може да съдържа само елементи
// HTML колекцията е жива, докато Node list може да е жив, но в повечето случаи е статичен.Имат length.

//  children - колекция, която връща всички преки наследници

// Итериране на колекция
//  - може да се индексира
//  - може да се обхождат с For Of
//  - може да се превърне в масив с Array.from
// const elementArr = Array.from(elements), където elements е колекцията

// parentElement or parentNode - начин за добиване на референция, чрез обхождане на ДОМ дървото. Ползва се за nodeList
// .children - връща HTML колекция, която връща само елементи (с тагове)


// зареждане на външни скриптове - <script src="app.js"></script>. Могат да се заредят повече от един, ИМА ЗНАЧЕНИЕ В КАКВА ПОСЛЕДОВАТЕЛНОСТ СА ЗАРЕДЕНИ

// element.style.display = 'none' - скрива елемента от CSS->display

// const thirdLi = document.querySelector('ul li:nth-child(3)') хваща третия li. Броят се от 1.(2n) хваща всеки втори. (3n) всеки 3-ти.(2n-1) взима нечетните.

//  Ако искаме да вземем например 3те елемента без първия и последния в Array.from: const costEl = Array.from(document.querySelectorAll('tr')).slice(1, -1);
//  (1, -1) означава да започне от индекс 1 до дължината - 1.
